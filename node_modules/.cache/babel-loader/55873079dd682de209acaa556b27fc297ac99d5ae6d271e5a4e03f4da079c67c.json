{"ast":null,"code":"'use strict';\n\nmodule.exports = function (timestamp) {\n  var wasWindowIdled = timestamp - this.previousTimeStamp > 100;\n  var isLoop = this.states[this.activeState].loop !== undefined ? this.states[this.activeState].loop : true;\n  var progressPercent, isLooping, nextGradient;\n\n  // If tab was inactive then resumed, reset the previous timestamp\n  if (this.previousTimeStamp === null || wasWindowIdled) {\n    this.previousTimeStamp = timestamp;\n  }\n\n  // Compute progress and save the timestamp\n  this.progress = this.progress + (timestamp - this.previousTimeStamp);\n  progressPercent = (this.progress / this.activetransitionSpeed * 100).toFixed(2);\n  this.previousTimeStamp = timestamp;\n\n  // Set the new gradient colors in a property\n  this.refreshColorsAndPos(progressPercent);\n\n  // Continue the animation or prepare for the next one\n  if (progressPercent < 100) {\n    this.animation = requestAnimationFrame(this.animateColors.bind(this));\n  } else {\n    // if the current animation index is inferior to the penultimate gradient\n    // or to the last gradient with the loop mode activated\n    if (this.channelsIndex < this.states[this.activeState].gradients.length - 2 || isLoop) {\n      // Set the active transition speed to the active state one after changing state\n      if (this.isChangingState) {\n        this.activetransitionSpeed = this.states[this.activeState].transitionSpeed || 5000;\n        this.isChangingState = false;\n      }\n\n      // Resetting properties\n      this.previousTimeStamp = null;\n      this.progress = 0;\n      this.channelsIndex++;\n      isLooping = false;\n\n      // If it's going to loop or if it's the transition after the loop\n      if (this.channelsIndex === this.states[this.activeState].gradients.length - 1) {\n        isLooping = true;\n      } else if (this.channelsIndex === this.states[this.activeState].gradients.length) {\n        this.channelsIndex = 0;\n      }\n\n      // Checking the next gradient to send in args of an event and a callback\n      nextGradient = this.states[this.activeState].gradients[this.channelsIndex + 1] === undefined ? this.states[this.activeState].gradients[0] : this.states[this.activeState].gradients[this.channelsIndex + 1];\n\n      // Compute the colors for the transition and render a new frame\n      this.setColors();\n      this.animation = requestAnimationFrame(this.animateColors.bind(this));\n\n      // Callback and Event\n      if (this.callbacks.onGradientChange) {\n        this.callbacks.onGradientChange({\n          isLooping: isLooping,\n          colorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\n          colorsTo: nextGradient,\n          activeState: this.activeState\n        });\n      }\n      this.canvas.dispatchEvent(this.events.gradientChange({\n        isLooping: isLooping,\n        colorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\n        colorsTo: nextGradient,\n        activeState: this.activeState\n      }));\n\n      // Else if it was the last gradient on the list and the loop mode is off\n    } else {\n      cancelAnimationFrame(this.animation);\n\n      // Callback and Event\n      if (this.callbacks.onEnd) this.callbacks.onEnd();\n      this.canvas.dispatchEvent(new CustomEvent('granim:end'));\n    }\n  }\n};","map":{"version":3,"names":["module","exports","timestamp","wasWindowIdled","previousTimeStamp","isLoop","states","activeState","loop","undefined","progressPercent","isLooping","nextGradient","progress","activetransitionSpeed","toFixed","refreshColorsAndPos","animation","requestAnimationFrame","animateColors","bind","channelsIndex","gradients","length","isChangingState","transitionSpeed","setColors","callbacks","onGradientChange","colorsFrom","colorsTo","canvas","dispatchEvent","events","gradientChange","cancelAnimationFrame","onEnd","CustomEvent"],"sources":["D:/eci/web/node_modules/granim/lib/animateColors.js"],"sourcesContent":["'use strict';\r\n\r\nmodule.exports = function(timestamp) {\r\n\tvar wasWindowIdled = timestamp - this.previousTimeStamp > 100;\r\n\tvar isLoop = this.states[this.activeState].loop !== undefined ? this.states[this.activeState].loop : true;\r\n\tvar progressPercent, isLooping, nextGradient;\r\n\r\n\t// If tab was inactive then resumed, reset the previous timestamp\r\n\tif (this.previousTimeStamp === null || wasWindowIdled) {\r\n\t\tthis.previousTimeStamp = timestamp;\r\n\t}\r\n\r\n\t// Compute progress and save the timestamp\r\n\tthis.progress = this.progress + (timestamp - this.previousTimeStamp);\r\n\tprogressPercent = (this.progress / this.activetransitionSpeed * 100).toFixed(2);\r\n\tthis.previousTimeStamp = timestamp;\r\n\r\n\t// Set the new gradient colors in a property\r\n\tthis.refreshColorsAndPos(progressPercent);\r\n\r\n\t// Continue the animation or prepare for the next one\r\n\tif (progressPercent < 100) {\r\n\t\tthis.animation = requestAnimationFrame(this.animateColors.bind(this));\r\n\r\n\t} else {\r\n\t\t// if the current animation index is inferior to the penultimate gradient\r\n\t\t// or to the last gradient with the loop mode activated\r\n\t\tif (this.channelsIndex < this.states[this.activeState].gradients.length - 2 || isLoop) {\r\n\r\n\t\t\t// Set the active transition speed to the active state one after changing state\r\n\t\t\tif (this.isChangingState) {\r\n\t\t\t\tthis.activetransitionSpeed = this.states[this.activeState].transitionSpeed || 5000;\r\n\t\t\t\tthis.isChangingState = false;\r\n\t\t\t}\r\n\r\n\t\t\t// Resetting properties\r\n\t\t\tthis.previousTimeStamp = null;\r\n\t\t\tthis.progress = 0;\r\n\t\t\tthis.channelsIndex++;\r\n\t\t\tisLooping = false;\r\n\r\n\t\t\t// If it's going to loop or if it's the transition after the loop\r\n\t\t\tif (this.channelsIndex === this.states[this.activeState].gradients.length - 1) {\r\n\t\t\t\tisLooping = true;\r\n\t\t\t\t\r\n\t\t\t} else if (this.channelsIndex === this.states[this.activeState].gradients.length) {\r\n\t\t\t\tthis.channelsIndex = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Checking the next gradient to send in args of an event and a callback\r\n\t\t\tnextGradient = this.states[this.activeState].gradients[this.channelsIndex + 1] === undefined ?\r\n\t\t\t\tthis.states[this.activeState].gradients[0] :\r\n\t\t\t\tthis.states[this.activeState].gradients[this.channelsIndex + 1];\r\n\r\n\t\t\t// Compute the colors for the transition and render a new frame\r\n\t\t\tthis.setColors();\r\n\t\t\tthis.animation = requestAnimationFrame(this.animateColors.bind(this));\r\n\t\t\t\r\n\t\t\t// Callback and Event\r\n\t\t\tif (this.callbacks.onGradientChange) {\r\n\t\t\t\tthis.callbacks.onGradientChange({\r\n\t\t\t\t\tisLooping: isLooping,\r\n\t\t\t\t\tcolorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\r\n\t\t\t\t\tcolorsTo: nextGradient,\r\n\t\t\t\t\tactiveState: this.activeState\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis.canvas.dispatchEvent(this.events.gradientChange({\r\n\t\t\t\tisLooping: isLooping,\r\n\t\t\t\tcolorsFrom: this.states[this.activeState].gradients[this.channelsIndex],\r\n\t\t\t\tcolorsTo: nextGradient,\r\n\t\t\t\tactiveState: this.activeState\r\n\t\t\t}));\r\n\r\n\t\t// Else if it was the last gradient on the list and the loop mode is off\r\n\t\t} else {\r\n\t\t\tcancelAnimationFrame(this.animation);\r\n\r\n\t\t\t// Callback and Event\r\n\t\t\tif (this.callbacks.onEnd) this.callbacks.onEnd();\r\n\t\t\tthis.canvas.dispatchEvent(new CustomEvent('granim:end'));\r\n\t\t}\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}