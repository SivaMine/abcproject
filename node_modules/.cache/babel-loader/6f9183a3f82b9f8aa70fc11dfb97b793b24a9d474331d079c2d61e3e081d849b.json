{"ast":null,"code":"var IntervalState;\n(function (IntervalState) {\n  IntervalState[IntervalState[\"IDLE\"] = 0] = \"IDLE\";\n  IntervalState[IntervalState[\"RUNNING\"] = 1] = \"RUNNING\";\n  IntervalState[IntervalState[\"PAUSED\"] = 2] = \"PAUSED\";\n  IntervalState[IntervalState[\"RESUME\"] = 3] = \"RESUME\";\n})(IntervalState || (IntervalState = {}));\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nclass IntervalTimer {\n  constructor(\n  /**\n   * Called after every interval.\n   */\n  callback,\n  /**\n   * Time between intervals, in milliseconds.\n   */\n  interval,\n  /**\n   * Maximum amount of fires.\n   */\n  maxFires) {\n    this.callback = callback;\n    this.interval = interval;\n    this.maxFires = maxFires;\n    /**\n     * The state to handle logic.\n     * - 0 means the interval is idle.\n     * - 1 means it's running.\n     * - 2 means it's paused\n     * - 3 will resume.\n     */\n    this.state = IntervalState.IDLE;\n    /**\n     * Remaining time before the next interval.\n     */\n    this.remaining = 0;\n    /**\n     * Amount of times fired.\n     */\n    this.fires = 0;\n    /**\n     * Time passed after pausing,\n     */\n    this.pausedTime = 0;\n    /**\n     * Handles the callback execution, the amount of fires, & the times when fired.\n     * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n     */\n    this.intervalHandler = () => {\n      if (this.maxFires != null && this.fires !== 0 && this.fires >= this.maxFires) {\n        this.stop();\n      } else {\n        this.lastTimeFired = new Date();\n        this.fires += 1;\n        this.callback();\n      }\n    };\n    /**\n     * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n     * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n     */\n    this.timeoutHandler = () => {\n      if (this.state !== IntervalState.RESUME) return;\n      this.pausedTime = 0;\n      this.intervalHandler();\n      this.start();\n    };\n    /**\n     * `start` executes the interval, and saves the interval ID for further use.\n     * The time of execution is also fired in case it's paused later on. The state\n     * is finally set as running.\n     */\n    this.start = () => {\n      this.timerId = setInterval(this.intervalHandler, this.interval);\n      this.lastTimeFired = new Date();\n      this.state = IntervalState.RUNNING;\n    };\n    /**\n     * `stop` clears every respective timeout and interval, then sets the state as idle.\n     */\n    this.stop = () => {\n      if (this.state === 0) return;\n      clearInterval(this.timerId);\n      clearTimeout(this.resumeId);\n      this.state = IntervalState.IDLE;\n    };\n    /**\n     * Resets the interval.\n     */\n    this.reset = () => {\n      this.stop();\n      this.start();\n    };\n    /**\n     * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n     * in a member variable. Afterwards clear the respective timeout and interval then set the new\n     * state.\n     */\n    this.pause = () => {\n      if (this.state !== IntervalState.RUNNING && this.state !== IntervalState.RESUME) return;\n      this.remaining = +this.interval - (+new Date() - +(this.lastTimeFired || 0)) + +this.pausedTime;\n      this.lastPauseTime = new Date();\n      clearInterval(this.timerId);\n      clearTimeout(this.resumeId);\n      this.state = IntervalState.PAUSED;\n    };\n    /**\n     * `resume` calculates the remaining time for the callback to trigger using the values\n     * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n     * as the timeout delay.\n     */\n    this.resume = () => {\n      if (this.state !== IntervalState.PAUSED) return;\n      const currentDate = new Date();\n      this.pausedTime = +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n      this.state = IntervalState.RESUME;\n      this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n    };\n    /**\n     * Set a new interval to use on the next interval loop.\n     */\n    this.setInterval = newInterval => {\n      if (this.state === 1) {\n        // If running we need to instantiate (new ID) the variable.\n        this.pause();\n        this.interval = newInterval;\n        this.resume();\n      } else {\n        // If stopped, idle, or paused then switch it.\n        this.interval = newInterval;\n      }\n    };\n    /**\n     * Maximum amount of times the `callback` member will execute, it's infinite by default.\n     */\n    this.setMaxFires = newMax => {\n      if (newMax != null && this.fires >= newMax) {\n        this.stop();\n      }\n      this.maxFires = newMax;\n    };\n  }\n  static new(callback, interval) {\n    let maxFires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    if (!this.instance) this.instance = new IntervalTimer(callback, interval, maxFires);else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\nexport { IntervalState, IntervalTimer as default };","map":{"version":3,"names":["IntervalState","IntervalTimer","constructor","callback","interval","maxFires","state","IDLE","remaining","fires","pausedTime","intervalHandler","stop","lastTimeFired","Date","timeoutHandler","RESUME","start","timerId","setInterval","RUNNING","clearInterval","clearTimeout","resumeId","reset","pause","lastPauseTime","PAUSED","resume","currentDate","setTimeout","newInterval","setMaxFires","newMax","new","arguments","length","undefined","instance"],"sources":["D:\\eci\\web\\node_modules\\hero-slider\\src\\modules\\IntervalTimer.ts"],"sourcesContent":["export enum IntervalState {\n  IDLE,\n  RUNNING,\n  PAUSED,\n  RESUME\n}\n\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nexport default class IntervalTimer {\n  /**\n   * The state to handle logic.\n   * - 0 means the interval is idle.\n   * - 1 means it's running.\n   * - 2 means it's paused\n   * - 3 will resume.\n   */\n  public state: IntervalState = IntervalState.IDLE;\n\n  /**\n   * Remaining time before the next interval.\n   */\n  public remaining: number = 0;\n\n  /**\n   * Amount of times fired.\n   */\n  public fires: number = 0;\n\n  /**\n   * Time passed after pausing,\n   */\n  public pausedTime: number | Date = 0;\n\n  private lastTimeFired?: Date;\n  private timerId?: NodeJS.Timer;\n  private resumeId?: NodeJS.Timeout;\n  private lastPauseTime?: Date;\n\n  private constructor(\n    /**\n     * Called after every interval.\n     */\n    public callback: () => void,\n    /**\n     * Time between intervals, in milliseconds.\n     */\n    public interval: number,\n    /**\n     * Maximum amount of fires.\n     */\n    public maxFires?: number\n  ) {}\n\n  /**\n   * Handles the callback execution, the amount of fires, & the times when fired.\n   * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n   */\n  private intervalHandler = () => {\n    if (\n      this.maxFires != null &&\n      this.fires !== 0 &&\n      this.fires >= this.maxFires\n    ) {\n      this.stop();\n    } else {\n      this.lastTimeFired = new Date();\n      this.fires += 1;\n      this.callback();\n    }\n  };\n\n  /**\n   * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n   * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n   */\n  private timeoutHandler = () => {\n    if (this.state !== IntervalState.RESUME) return;\n\n    this.pausedTime = 0;\n    this.intervalHandler();\n    this.start();\n  };\n\n  /**\n   * `start` executes the interval, and saves the interval ID for further use.\n   * The time of execution is also fired in case it's paused later on. The state\n   * is finally set as running.\n   */\n  public start = () => {\n    this.timerId = setInterval(this.intervalHandler, this.interval);\n    this.lastTimeFired = new Date();\n    this.state = IntervalState.RUNNING;\n  };\n\n  /**\n   * `stop` clears every respective timeout and interval, then sets the state as idle.\n   */\n  public stop = () => {\n    if (this.state === 0) return;\n\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.IDLE;\n  };\n\n  /**\n   * Resets the interval.\n   */\n  public reset = () => {\n    this.stop();\n    this.start();\n  };\n\n  /**\n   * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n   * in a member variable. Afterwards clear the respective timeout and interval then set the new\n   * state.\n   */\n  public pause = () => {\n    if (\n      this.state !== IntervalState.RUNNING &&\n      this.state !== IntervalState.RESUME\n    )\n      return;\n\n    this.remaining =\n      +this.interval -\n      (+new Date() - +(this.lastTimeFired || 0)) +\n      +this.pausedTime;\n    this.lastPauseTime = new Date();\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.PAUSED;\n  };\n\n  /**\n   * `resume` calculates the remaining time for the callback to trigger using the values\n   * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n   * as the timeout delay.\n   */\n  public resume = () => {\n    if (this.state !== IntervalState.PAUSED) return;\n    const currentDate = new Date();\n    this.pausedTime =\n      +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n    this.state = IntervalState.RESUME;\n    this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n  };\n\n  /**\n   * Set a new interval to use on the next interval loop.\n   */\n  public setInterval = (newInterval: number) => {\n    if (this.state === 1) {\n      // If running we need to instantiate (new ID) the variable.\n      this.pause();\n      this.interval = newInterval;\n      this.resume();\n    } else {\n      // If stopped, idle, or paused then switch it.\n      this.interval = newInterval;\n    }\n  };\n\n  /**\n   * Maximum amount of times the `callback` member will execute, it's infinite by default.\n   */\n  public setMaxFires = (newMax: number) => {\n    if (newMax != null && this.fires >= newMax) {\n      this.stop();\n    }\n    this.maxFires = newMax;\n  };\n\n  private static instance: IntervalTimer | undefined;\n\n  public static new(\n    callback: () => void,\n    interval: number,\n    maxFires: number | undefined = undefined\n  ): IntervalTimer {\n    if (!this.instance)\n      this.instance = new IntervalTimer(callback, interval, maxFires);\n    else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}